#!/usr/bin/env node
"use strict";

var colors = require("colors");

colors.setTheme({
	pass: "green",
	warn: "yellow",
	error: "red"
});

if (require.main === module) {
	var cmd = require("./../lib/cmd"),
		cnf = require("./../lib/readConfig"),
		cli = require("cli"),
		pkg = require("../package.json"),
		successMsg = "clean-bower-installer execution successfully done!";

	/**
	 * Format the verbose CLI return
	 *
	 * @param list {Array}
	 * @returns {string}
	 */
	var verboseCLIReturn = function(list) {
		var output = "";
		for (var i = 0, j = list.length; i < j; i++) {
			output += "Copied '" + list[i].from + "' to '" + list[i].to + "'\n";
		}
		return output;
	};

	// Version display
	cli.setApp(pkg.name, pkg.version);
	cli.enable("version");

	// CLI options
	cli.parse({
		automatic: ["a", "Automatically select the right option to execute from bower."],
		install: ["i", "Run bower install command"],
		update: ["u", "Run bower update command"],
		bower: [false, "Input the bower.json file path.", "path", null],
		min: ["m", "Try to get .min file version first."],
		renameMin: ["M", "Try to get .min file version first and keep the name specified in the bower.json file."],
		verbose: ["V", "Get more information from the tool."],
		removeAfter: ["r", "Remove the bower_components folder after execution."]
	}, null);

	cli.main(function(args, options) {
		cnf.read({cwd: options.bower}).then(
			function(config) {
				if (options.verbose) {
					config.option.verbose = true;
				}

				if (options.removeAfter) {
					config.option.removeAfter = true;
				}

				// Add load of minimised file version and renaming of them if needed
				if (options.renameMin) {
					config.option.min.get = true;
					config.option.min.rename = true;
				} else if (options.min) {
					config.option.min.get = true;
					config.option.min.rename = false;
				} else {
					config.option.min.get = false;
					config.option.min.rename = false;
				}

				// Actions
				if (options.automatic) {
					cmd.automatic(config).then(
						function(message) {
							if (config.option.verbose) {
								console.log(verboseCLIReturn(message));
							}
							console.log(successMsg.pass);
							process.exit(0);
						}, function(err) {
							console.log(err.error);
							process.exit(1);
						}
					);
				} else if (options.install) {
					cmd.install(config).then(
						function(message) {
							if (config.option.verbose) {
								console.log(verboseCLIReturn(message));
							}
							console.log(successMsg.pass);
							process.exit(0);
						}, function(err) {
							console.log(err.error);
							process.exit(1);
						}
					);
				} else if (options.update) {
					cmd.update(config).then(
						function(message) {
							if (config.option.verbose) {
								console.log(verboseCLIReturn(message));
							}
							console.log(successMsg.pass);
							process.exit(0);
						}, function(err) {
							console.log(err.error);
							process.exit(1);
						}
					);
				} else {
					cmd.run(config).then(
						function(message) {
							if (config.option.verbose) {
								console.log(verboseCLIReturn(message));
							}
							console.log(successMsg.pass);
							process.exit(0);
						}, function(err) {
							console.log(err.error);
							process.exit(1);
						}
					);
				}
			}, function(err) {
				console.error(err);
			}
		);
	});
} else {
	var api = require("./../lib/api");
	module.exports = {
		automatic: api.automatic,
		install: api.install,
		update: api.install,
		run: api.run,
		runMin: api.runMin,
		runMinR: api.runMinR
	};
}